/****************************************************************************
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <https://unlicense.org>
 ***************************************************************************/
/*---------------------------------------------------------------------------
    HALKEN LZ Routine v1.00

    Author  : White Guy That Don't Smile
    Date    : 2022/01/13, Thursday, January 13th; 1750 HOURS
    License : UnLicense | Public Domain

    This is a Lempel-Ziv compression routine siphoned from the
    AGB SDK tool "agbcomp" - modified to comply with the parameters
    recorded from decoded sample data generated by HAL Laboratory.

    ####  Confirmed LZ Parameters  ####

    Minimum Offset : 0x0001 , Minimum Length : 0x03
    Maximum Offset : 0xFFFF , Maximum Length : 0xFF

    0 Flag : Process 8 bits, verbatim.
    1 Flag : Process Length-Displacement information.

    ####  Supplementary Hypothetical Parameters  ####

    < IF >
        the next reference address, is uneven
        | OR |
        the initial match offset, plus two,
        is not-equal to
        the lookahead match offset
        | OR |
        the lookahead match length minus the initial match length,
        is less-than or equal-to
        three
    < THEN >
        go to the end of the loop
---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------
    ####  LZ Audits  ####

    <  Nintendo 64  >

        [N64] : Kirby 64: The Crystal Shards
        [???? / ????] : To do....

        [N64] : Pokémon Snap
        [EUR][0003 / 0003] : Success
        [JAP][0003 / 0003] : Success
        [USA][0003 / 0003] : Success

        [N64] : Shigesato Itoi's No. 1 Bass Fishing - Definitive Edition!
        [JAP][0001 / 0001] : Success

        [N64] : Super Smash Bros.
        [EUR][0516 / 0516] : Success
        [JAP][0474 / 0474] : Success
        [USA][0498 / 0498] : Success

    <  Game Boy Advance  >

        [AGB] : e-Reader ROM
        [JAP][0003 / 0003] : Success
        [JAP][0004 / 0004] : Success [e-Reader+]
        [USA][0003 / 0003] : Success

        [AGB] : Pokémon Emerald Version
        [0001 / 0001] : Success

        [AGB] : Pokémon FireRed Version
        [0001 / 0001] : Success

        [AGB] : Pokémon LeafGreen Version
        [0001 / 0001] : Success

        [AGB] : Super Mario Advance 4 - Super Mario Bros. 3
        [0001 / 0001] : Success
---------------------------------------------------------------------------*/



typedef   signed char  i8;
typedef unsigned char  u8;
typedef   signed short i16;
typedef unsigned short u16;
#ifdef __x86_64__
typedef   signed int   i32;
typedef unsigned int   u32;
#else
typedef   signed long  i32;
typedef unsigned long  u32;
#endif



static void _search( u8 *src, u32 srcpos, const u32 srclen,
                     u32 *match_offset, u32 *match_length )
{
  u8 *head;
  u8 *tail;
  u32 offset;
  u32 length;
  u32 window;

  *match_offset = 0;
  *match_length = 0;
  offset = 1;
  window = (srcpos < 0x10000) ? 1 : (srcpos - 0xFFFF);

  while ( (window <= srcpos) && (offset < 0x10000) && (srcpos < srclen) )
  {
    tail = &src[((i32)srcpos - offset)];

    if ( *tail == src[srcpos] )
    {
      length = 1;
      head   = &src[srcpos];

      while ( (*++head == *++tail) && (++length < 0x100) );

      if ( 0xFF < length )
      {
        length = 0xFF;
      }

      if ( srclen <= (srcpos + length) )
      {
        length = srclen - srcpos;
      }

      if ( (2 < length) && (*match_length < length) )
      {
        *match_offset = offset;
        *match_length = length;
      }
    }

    offset++;
    window++;
  }

  return;
}



/*---------------------------------------------------------------------------
    < u8 *src >
    An allocated source buffer filled with the contents of an input file.
    < u32 srclen >
    Length of the source buffer (input file).
---------------------------------------------------------------------------*/
static void encodeLZ( u8 *src, const u32 srclen )
{
  u32 srcpos;
  u32 match_offset;
  u32 match_length;
  u32 lookahead_offset;
  u32 lookahead_length;

  srcpos = 0;

  while ( srcpos < srclen )
  {
    _search( src, srcpos, srclen,
             &match_offset, &match_length );

    if ( match_length < 3U )
    {
      srcpos++;
    }
    else
    {
      _search( src, (srcpos + 1U), srclen,
               &lookahead_offset, &lookahead_length );

      if ( (match_length + 1U) <= lookahead_length )
      {
        srcpos++;

        /*---------------------------------------------
        Testing against these conditions seems to fall
        in line with the method needed to reproduce the
        LZ data siphoned from preexisting "vpk0" data.
        ---------------------------------------------*/
        if (    (srcpos & 1)
             || ((match_offset + 2U) != lookahead_offset)
             || ((lookahead_length - match_length) <= 3) )
        {
          continue;
        }
        else
        {
          match_offset = lookahead_offset;
          match_length = lookahead_length;
        }
      }

      srcpos += match_length;
    }
  }

  return;
}
